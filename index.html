<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PolyOracle V2 â€¢ Sentient</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ¦Œ</text></svg>">
    
    <!-- Fonts & Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Azeret+Mono:wght@400;500;600;700&family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Libraries -->
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <style>
        :root {
            --bg: #0b0c10;
            --panel: #13151b;
            --panel-border: #1f2229;
            --primary: #5de4c8; /* Teal for optimistic tech */
            --accent: #6f5ce6;  /* Purple for deep AI */
            --bull: #2ebd85;
            --bear: #f6465d;
            --text-main: #e1e3e6;
            --text-muted: #848e9c;
            --font-mono: 'Azeret Mono', monospace;
            --font-sans: 'Inter', sans-serif;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; background: var(--bg); color: var(--text-main); font-family: var(--font-sans); overflow-x: hidden; }

        /* HEADER */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--panel);
            border-bottom: 1px solid var(--panel-border);
            height: 60px;
        }
        .logo { font-weight: 800; font-size: 1.1rem; letter-spacing: -0.02em; display: flex; align-items: center; gap: 8px; }
        .logo span { color: var(--primary); }
        
        .source-selector {
            background: #000;
            border: 1px solid var(--panel-border);
            color: var(--text-main);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.8rem;
            font-family: var(--font-mono);
            cursor: pointer;
            outline: none;
        }
        .source-selector:focus { border-color: var(--primary); }

        /* LAYOUT */
        .grid-container {
            display: grid;
            grid-template-columns: 1fr 300px;
            height: calc(100vh - 60px);
            overflow: hidden;
        }

        /* MAIN CHART AREA */
        .chart-section {
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--panel-border);
            position: relative;
        }
        .chart-controls {
            display: flex;
            gap: 8px;
            padding: 8px 16px;
            background: var(--bg);
            border-bottom: 1px solid var(--panel-border);
            overflow-x: auto;
        }
        .btn-sm {
            background: var(--panel);
            border: 1px solid var(--panel-border);
            color: var(--text-muted);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-sm.active { background: var(--panel-border); color: var(--text-main); border-color: var(--text-muted); }
        .btn-sm:hover { color: var(--text-main); }

        #tv-chart-container {
            flex: 1;
            width: 100%;
            position: relative;
        }

        /* PRICE TICKER OVERLAY */
        .price-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            pointer-events: none;
        }
        .current-price { font-size: 1.8rem; font-weight: 700; font-family: var(--font-mono); text-shadow: 0 2px 10px rgba(0,0,0,0.5); }
        .price-change { font-size: 0.9rem; font-weight: 500; margin-left: 6px; }
        .bullish { color: var(--bull); }
        .bearish { color: var(--bear); }

        /* SIDEBAR */
        .sidebar {
            background: var(--panel);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        /* AI SECTION */
        .ai-panel {
            padding: 16px;
            border-bottom: 1px solid var(--panel-border);
            background: linear-gradient(180deg, rgba(93, 228, 200, 0.05) 0%, transparent 100%);
        }
        .ai-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .ai-title { font-size: 0.8rem; font-weight: 700; color: var(--primary); text-transform: uppercase; letter-spacing: 1px; }
        .ai-badge { background: var(--primary); color: #000; font-size: 0.6rem; padding: 2px 6px; border-radius: 4px; font-weight: 800; }
        
        .prediction-box {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(0,0,0,0.3);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--panel-border);
            margin-bottom: 12px;
        }
        .pred-dir { font-size: 1.2rem; font-weight: 800; }
        .pred-conf { font-family: var(--font-mono); font-size: 0.9rem; color: var(--text-muted); }

        .terminal-log {
            font-family: var(--font-mono);
            font-size: 0.7rem;
            color: var(--text-muted);
            height: 100px;
            overflow-y: auto;
            background: #000;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid var(--panel-border);
            line-height: 1.4;
        }
        .log-entry { margin-bottom: 4px; }
        .log-time { color: var(--accent); margin-right: 6px; }

        /* PREDICTION GAME */
        .game-panel { padding: 16px; flex: 1; }
        .game-header { font-size: 0.9rem; font-weight: 600; margin-bottom: 12px; display: flex; justify-content: space-between; }
        
        .bet-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px; }
        .btn-bet {
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-weight: 700;
            cursor: pointer;
            font-size: 1rem;
            transition: transform 0.1s;
            position: relative;
            overflow: hidden;
        }
        .btn-bet:active { transform: scale(0.97); }
        .btn-up { background: rgba(46, 189, 133, 0.15); color: var(--bull); border: 1px solid var(--bull); }
        .btn-down { background: rgba(246, 70, 93, 0.15); color: var(--bear); border: 1px solid var(--bear); }
        .btn-bet:hover { opacity: 0.9; }

        /* ODDS DISPLAY */
        .poly-odds {
            font-size: 0.7rem;
            text-align: center;
            margin-top: 4px;
            opacity: 0.8;
            font-family: var(--font-mono);
        }

        /* HISTORY */
        .history-list { margin-top: 20px; }
        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            padding: 8px 0;
            border-bottom: 1px solid var(--panel-border);
        }
        .h-time { color: var(--text-muted); }
        .h-res.win { color: var(--bull); }
        .h-res.loss { color: var(--bear); }

        /* LOADING */
        #loader {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: var(--bg); z-index: 999;
            display: flex; justify-content: center; align-items: center;
            transition: opacity 0.5s;
        }
        .loader-content { text-align: center; }
        .spinner {
            width: 40px; height: 40px; border: 3px solid var(--panel-border);
            border-top-color: var(--primary); border-radius: 50%;
            animation: spin 1s linear infinite; margin: 0 auto 16px;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        /* MOBILE RESPONSIVE */
        @media (max-width: 768px) {
            .grid-container { grid-template-columns: 1fr; grid-template-rows: 1fr auto; height: auto; display: block; }
            .chart-section { height: 60vh; border-right: none; border-bottom: 1px solid var(--panel-border); }
            .sidebar { height: auto; }
            #tv-chart-container { min-height: 400px; }
        }
    </style>
</head>
<body>

    <!-- LOADER -->
    <div id="loader">
        <div class="loader-content">
            <div class="spinner"></div>
            <div style="font-family: var(--font-mono); font-size: 0.8rem; color: var(--text-muted);">INITIALIZING ORACLE...</div>
        </div>
    </div>

    <!-- HEADER -->
    <header>
        <div class="logo">
            <i class="fa-solid fa-chart-line" style="color:var(--primary)"></i>
            POLY<span>ORACLE</span>
        </div>
        <select id="sourceSelect" class="source-selector" onchange="app.switchSource(this.value)">
            <option value="BINANCE">âš¡ BINANCE (LIVE)</option>
            <option value="CHAINLINK">â›“ CHAINLINK (ON-CHAIN)</option>
            <option value="COINGECKO">ðŸ¦Ž COINGECKO (AVG)</option>
        </select>
    </header>

    <div class="grid-container">
        
        <!-- CHART SECTION -->
        <div class="chart-section">
            <div class="chart-controls">
                <!-- Timeframes -->
                <button class="btn-sm active" onclick="app.setTF('1m', this)">1m</button>
                <button class="btn-sm" onclick="app.setTF('5m', this)">5m</button>
                <button class="btn-sm" onclick="app.setTF('15m', this)">15m</button>
                <button class="btn-sm" onclick="app.setTF('1h', this)">1H</button>
                <div style="width: 1px; background: var(--panel-border); margin: 0 4px;"></div>
                <!-- Types -->
                <button class="btn-sm active" onclick="app.setChartType('candle', this)">Candles</button>
                <button class="btn-sm" onclick="app.setChartType('ha', this)">Heikin Ashi</button>
                <button class="btn-sm" onclick="app.setChartType('line', this)">Line</button>
            </div>

            <div class="price-overlay">
                <div id="priceDisplay" class="current-price">Loading...</div>
                <div id="priceChange" class="price-change">--%</div>
            </div>

            <div id="tv-chart-container"></div>
        </div>

        <!-- SIDEBAR -->
        <div class="sidebar">
            
            <!-- AI PANEL -->
            <div class="ai-panel">
                <div class="ai-header">
                    <div class="ai-title"><i class="fa-solid fa-brain"></i> Sentient AI</div>
                    <div class="ai-badge">V2.4 ONLINE</div>
                </div>
                <div class="prediction-box">
                    <div>
                        <div style="font-size:0.7rem; color:var(--text-muted); margin-bottom:4px;">NEXT 5M CANDLE</div>
                        <div id="aiDirection" class="pred-dir" style="color:var(--text-muted)">ANALYZING...</div>
                    </div>
                    <div style="text-align:right">
                        <div style="font-size:0.7rem; color:var(--text-muted); margin-bottom:4px;">CONFIDENCE</div>
                        <div id="aiConfidence" class="pred-conf">--%</div>
                    </div>
                </div>
                <div id="aiTerminal" class="terminal-log">
                    <div class="log-entry"><span class="log-time">SYS:</span> Neural Engine Initialized.</div>
                </div>
            </div>

            <!-- BETTING PANEL -->
            <div class="game-panel">
                <div class="game-header">
                    <span>Active Market</span>
                    <span id="nextCloseTimer" style="font-family:var(--font-mono); color:var(--primary)">00:00</span>
                </div>

                <div class="bet-buttons">
                    <button class="btn-bet btn-up" onclick="app.placeBet('UP')">
                        <i class="fa-solid fa-arrow-trend-up"></i> UP
                        <div class="poly-odds">Odds: <span id="oddsUp">50</span>%</div>
                    </button>
                    <button class="btn-bet btn-down" onclick="app.placeBet('DOWN')">
                        <i class="fa-solid fa-arrow-trend-down"></i> DOWN
                        <div class="poly-odds">Odds: <span id="oddsDown">50</span>%</div>
                    </button>
                </div>

                <div class="game-header" style="margin-top:30px;">
                    <span>Position History</span>
                    <span id="winRate">WR: 0%</span>
                </div>
                <div id="historyList" class="history-list">
                    <!-- History items injected here -->
                </div>
            </div>

        </div>
    </div>

    <script>
        // --- CONSTANTS & CONFIG ---
        const CONFIG = {
            binanceWS: 'wss://stream.binance.com:9443/ws/btcusdt@kline_',
            coingeckoAPI: 'https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd&include_24hr_change=true',
            // Chainlink BTC/USD Mainnet Proxy
            chainlinkAddress: '0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c', 
            rpcUrl: 'https://eth.llamarpc.com', // Public RPC
            polymarketAPI: 'https://clob.polymarket.com/prices-history', // Mocking for now as we don't have a backend proxy
        };

        const ABI = [
            "function latestRoundData() view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)",
            "function decimals() view returns (uint8)"
        ];

        // --- CORE APPLICATION CLASS ---
        class OracleApp {
            constructor() {
                this.source = 'BINANCE'; // BINANCE | CHAINLINK | COINGECKO
                this.timeframe = '1m';
                this.chartType = 'candle'; // candle | ha | line
                this.chart = null;
                this.series = null;
                this.ws = null;
                this.dataBuffer = []; // Store candles
                this.currentPrice = 0;
                this.bets = JSON.parse(localStorage.getItem('elk_bets') || '[]');
                this.provider = new ethers.providers.JsonRpcProvider(CONFIG.rpcUrl);
                
                this.initChart();
                this.startDataStream();
                this.renderHistory();
                this.startGameLoop();
                
                // Remove loader
                setTimeout(() => document.getElementById('loader').style.opacity = 0, 1000);
                setTimeout(() => document.getElementById('loader').style.display = 'none', 1500);
            }

            // --- CHARTING ENGINE ---
            initChart() {
                const container = document.getElementById('tv-chart-container');
                this.chart = LightweightCharts.createChart(container, {
                    layout: { background: { color: '#0b0c10' }, textColor: '#848e9c' },
                    grid: { vertLines: { color: '#1f2229' }, horzLines: { color: '#1f2229' } },
                    crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                    timeScale: { timeVisible: true, secondsVisible: false, borderColor: '#1f2229' },
                    rightPriceScale: { borderColor: '#1f2229' },
                });

                this.setChartSeries();
                
                // Resize Observer
                new ResizeObserver(entries => {
                    if (entries.length === 0 || entries[0].target !== container) { return; }
                    const newRect = entries[0].contentRect;
                    this.chart.applyOptions({ height: newRect.height, width: newRect.width });
                }).observe(container);
            }

            setChartSeries() {
                if (this.series) this.chart.removeSeries(this.series);
                
                if (this.chartType === 'line') {
                    this.series = this.chart.addLineSeries({ color: '#5de4c8', lineWidth: 2 });
                } else {
                    this.series = this.chart.addCandlestickSeries({
                        upColor: '#2ebd85', downColor: '#f6465d',
                        borderUpColor: '#2ebd85', borderDownColor: '#f6465d',
                        wickUpColor: '#2ebd85', wickDownColor: '#f6465d',
                    });
                }
                
                // Re-feed data if exists
                if (this.dataBuffer.length > 0) {
                    this.updateChartData();
                }
            }

            setChartType(type, btn) {
                this.chartType = type;
                document.querySelectorAll('.chart-controls button').forEach(b => {
                    if (['Candles', 'Heikin Ashi', 'Line'].includes(b.innerText)) b.classList.remove('active');
                });
                btn.classList.add('active');
                this.setChartSeries();
            }

            setTF(tf, btn) {
                this.timeframe = tf;
                document.querySelectorAll('.chart-controls button').forEach(b => {
                    if (['1m', '5m', '15m', '1H'].includes(b.innerText)) b.classList.remove('active');
                });
                btn.classList.add('active');
                
                // Restart stream with new TF
                this.dataBuffer = []; 
                this.startDataStream();
            }

            // --- DATA ENGINE ---
            switchSource(newSource) {
                this.source = newSource;
                this.log(`Source switched to ${newSource}`);
                this.dataBuffer = [];
                this.startDataStream();
            }

            startDataStream() {
                // Clear existing intervals/WS
                if (this.ws) this.ws.close();
                if (this.pollInterval) clearInterval(this.pollInterval);

                if (this.source === 'BINANCE') {
                    this.connectBinance();
                } else if (this.source === 'CHAINLINK') {
                    this.connectChainlink();
                } else {
                    this.connectCoinGecko();
                }
            }

            connectBinance() {
                const tfMap = { '1m': '1m', '5m': '5m', '15m': '15m', '1h': '1h' };
                this.ws = new WebSocket(`${CONFIG.binanceWS}${tfMap[this.timeframe]}`);
                
                this.ws.onmessage = (event) => {
                    const msg = JSON.parse(event.data);
                    const k = msg.k;
                    
                    const candle = {
                        time: k.t / 1000,
                        open: parseFloat(k.o),
                        high: parseFloat(k.h),
                        low: parseFloat(k.l),
                        close: parseFloat(k.c)
                    };

                    this.processCandle(candle);
                };
            }

            async connectChainlink() {
                this.log("Connecting to Ethereum Mainnet...");
                const contract = new ethers.Contract(CONFIG.chainlinkAddress, ABI, this.provider);
                
                const fetchPrice = async () => {
                    try {
                        const data = await contract.latestRoundData();
                        // Chainlink BTC feed has 8 decimals
                        const price = parseFloat(ethers.utils.formatUnits(data.answer, 8));
                        const time = Math.floor(Date.now() / 1000); // Chainlink updates are sporadic, so we synthesize a timeline
                        
                        // Fake a candle structure for visual continuity
                        const candle = {
                            time: time,
                            open: price, high: price, low: price, close: price 
                        };
                        this.processCandle(candle, true);
                    } catch (e) {
                        this.log("RPC Error: " + e.message);
                    }
                };

                fetchPrice();
                this.pollInterval = setInterval(fetchPrice, 15000); // Poll every 15s (approx block time)
            }

            connectCoinGecko() {
                const fetchPrice = async () => {
                    try {
                        const res = await fetch(CONFIG.coingeckoAPI);
                        const data = await res.json();
                        const price = data.bitcoin.usd;
                        const time = Math.floor(Date.now() / 1000);
                        
                        const candle = {
                            time: time,
                            open: price, high: price, low: price, close: price
                        };
                        this.processCandle(candle, true);
                    } catch (e) {
                        console.error(e);
                    }
                };
                fetchPrice();
                this.pollInterval = setInterval(fetchPrice, 10000);
            }

            processCandle(candle, isLineSource = false) {
                // Update Current Price UI
                this.currentPrice = candle.close;
                const elPrice = document.getElementById('priceDisplay');
                const prev = parseFloat(elPrice.dataset.prev || 0);
                
                elPrice.innerText = '$' + this.currentPrice.toLocaleString(undefined, {minimumFractionDigits: 2});
                elPrice.dataset.prev = this.currentPrice;
                elPrice.className = `current-price ${this.currentPrice >= prev ? 'bullish' : 'bearish'}`;

                // Manage Data Buffer
                // For Binance (candles), we update the last candle if time matches, else push new
                if (this.dataBuffer.length > 0) {
                    const last = this.dataBuffer[this.dataBuffer.length - 1];
                    if (isLineSource) {
                        // For line sources, we just create a new point every poll unless user wants strict candles
                        // To make it look like a chart, we might need to construct candles manually.
                        // For simplicity in this demo, we treat poll sources as 1m line mostly.
                        if (candle.time - last.time < 60) {
                             // update last candle
                             last.close = candle.close;
                             last.high = Math.max(last.high, candle.close);
                             last.low = Math.min(last.low, candle.close);
                             this.dataBuffer[this.dataBuffer.length - 1] = last;
                        } else {
                            this.dataBuffer.push(candle);
                        }
                    } else {
                        // Binance logic
                        if (last.time === candle.time) {
                            this.dataBuffer[this.dataBuffer.length - 1] = candle;
                        } else {
                            this.dataBuffer.push(candle);
                        }
                    }
                } else {
                    this.dataBuffer.push(candle);
                }

                // Limit buffer size
                if (this.dataBuffer.length > 500) this.dataBuffer.shift();

                this.updateChartData();
                this.runAIAnalysis();
            }

            updateChartData() {
                let displayData = [...this.dataBuffer];

                // Heikin Ashi Transformation
                if (this.chartType === 'ha') {
                    const haData = [];
                    for (let i = 0; i < displayData.length; i++) {
                        const d = displayData[i];
                        const prevHA = i > 0 ? haData[i - 1] : d;
                        
                        const haOpen = (prevHA.open + prevHA.close) / 2;
                        const haClose = (d.open + d.high + d.low + d.close) / 4;
                        const haHigh = Math.max(d.high, haOpen, haClose);
                        const haLow = Math.min(d.low, haOpen, haClose);
                        
                        haData.push({ time: d.time, open: haOpen, high: haHigh, low: haLow, close: haClose });
                    }
                    displayData = haData;
                }

                // Format for Line Chart
                if (this.chartType === 'line') {
                    displayData = displayData.map(d => ({ time: d.time, value: d.close }));
                }

                this.series.setData(displayData);
            }

            // --- AI SENTIENT ENGINE ---
            runAIAnalysis() {
                if (this.dataBuffer.length < 14) return; // Need data for RSI

                const closes = this.dataBuffer.map(c => c.close);
                const rsi = this.calculateRSI(closes, 14);
                const lastRSI = rsi[rsi.length - 1];
                
                // Simple Bollinger Band Width Logic (Volatility)
                const ma = closes.slice(-20).reduce((a,b)=>a+b,0)/20;
                const dev = Math.sqrt(closes.slice(-20).map(x=>Math.pow(x-ma,2)).reduce((a,b)=>a+b,0)/20);
                const upper = ma + (2*dev);
                const lower = ma - (2*dev);
                const bbPos = (closes[closes.length-1] - lower) / (upper - lower); // 0 to 1

                let score = 0; // -10 to 10
                let reasons = [];

                // RSI Logic
                if (lastRSI > 70) { score -= 3; reasons.push(`RSI Overbought (${lastRSI.toFixed(0)})`); }
                else if (lastRSI < 30) { score += 3; reasons.push(`RSI Oversold (${lastRSI.toFixed(0)})`); }
                else { reasons.push("RSI Neutral"); }

                // Trend Logic
                const emaShort = this.calculateEMA(closes, 9);
                const emaLong = this.calculateEMA(closes, 21);
                if (emaShort > emaLong) { score += 4; reasons.push("Golden Cross Trend"); }
                else { score -= 4; reasons.push("Death Cross Trend"); }

                // Price Action
                const lastCandle = this.dataBuffer[this.dataBuffer.length-1];
                if (lastCandle.close > lastCandle.open) score += 1;
                else score -= 1;

                // Output
                const confidence = Math.min(Math.abs(score) * 10, 99);
                const direction = score > 0 ? "BULLISH" : (score < 0 ? "BEARISH" : "NEUTRAL");
                
                // UI Update
                const elDir = document.getElementById('aiDirection');
                elDir.innerText = direction;
                elDir.className = `pred-dir ${score > 0 ? 'bullish' : 'bearish'}`;
                document.getElementById('aiConfidence').innerText = confidence + '%';

                // Log rare events
                if (Math.random() > 0.95 || this.lastLogTime === undefined || Date.now() - this.lastLogTime > 10000) {
                    this.log(`${reasons[0]} detected. Probability updated.`);
                    this.lastLogTime = Date.now();
                }
            }

            calculateRSI(prices, period) {
                let gains = 0, losses = 0;
                for (let i = 1; i <= period; i++) {
                    const diff = prices[i] - prices[i - 1];
                    if (diff >= 0) gains += diff; else losses -= diff;
                }
                let avgGain = gains / period;
                let avgLoss = losses / period;
                const rsis = [];
                for (let i = period + 1; i < prices.length; i++) {
                    const diff = prices[i] - prices[i - 1];
                    avgGain = (avgGain * (period - 1) + (diff > 0 ? diff : 0)) / period;
                    avgLoss = (avgLoss * (period - 1) + (diff < 0 ? -diff : 0)) / period;
                    const rs = avgGain / avgLoss;
                    rsis.push(100 - (100 / (1 + rs)));
                }
                return rsis;
            }

            calculateEMA(prices, period) {
                const k = 2 / (period + 1);
                let ema = prices[0];
                for (let i = 1; i < prices.length; i++) {
                    ema = prices[i] * k + ema * (1 - k);
                }
                return ema;
            }

            log(msg) {
                const term = document.getElementById('aiTerminal');
                const time = new Date().toLocaleTimeString('en-US', {hour12:false, hour:'2-digit', minute:'2-digit', second:'2-digit'});
                const div = document.createElement('div');
                div.className = 'log-entry';
                div.innerHTML = `<span class="log-time">[${time}]</span> ${msg}`;
                term.insertBefore(div, term.firstChild);
                if (term.children.length > 20) term.lastChild.remove();
            }

            // --- GAME LOGIC ---
            startGameLoop() {
                setInterval(() => {
                    const now = new Date();
                    const min = now.getMinutes();
                    const sec = now.getSeconds();
                    const next5m = 5 - (min % 5);
                    const secLeft = (next5m * 60) - sec;
                    
                    const m = Math.floor(secLeft / 60);
                    const s = secLeft % 60;
                    document.getElementById('nextCloseTimer').innerText = `${m}:${s < 10 ? '0'+s : s}`;
                    
                    // Check bets
                    this.checkBets();
                }, 1000);
            }

            placeBet(direction) {
                if (!this.currentPrice) return;
                
                const now = new Date();
                const currentMin = now.getMinutes();
                // Settlement time is next 5 minute mark
                const remainder = 5 - (currentMin % 5);
                const settleTime = new Date(now.getTime() + remainder * 60000);
                settleTime.setSeconds(0);
                settleTime.setMilliseconds(0);

                const bet = {
                    id: Date.now(),
                    time: now.toLocaleTimeString(),
                    entry: this.currentPrice,
                    direction: direction,
                    settleTime: settleTime.getTime(),
                    status: 'OPEN',
                    source: this.source // Save which source was used!
                };

                this.bets.unshift(bet);
                this.saveBets();
                this.renderHistory();
                this.log(`Order placed: ${direction} @ ${this.currentPrice} (${this.source})`);
            }

            checkBets() {
                let changed = false;
                const now = Date.now();
                
                this.bets.forEach(bet => {
                    if (bet.status === 'OPEN' && now >= bet.settleTime) {
                        // Settle
                        const win = (bet.direction === 'UP' && this.currentPrice > bet.entry) ||
                                    (bet.direction === 'DOWN' && this.currentPrice < bet.entry);
                        
                        bet.status = win ? 'WIN' : 'LOSS';
                        bet.exit = this.currentPrice;
                        changed = true;
                        
                        // Simple toast
                        this.log(`Bet Settled: ${bet.status}`);
                    }
                });

                if (changed) {
                    this.saveBets();
                    this.renderHistory();
                }
            }

            saveBets() {
                localStorage.setItem('elk_bets', JSON.stringify(this.bets));
            }

            renderHistory() {
                const list = document.getElementById('historyList');
                list.innerHTML = '';
                
                let wins = 0;
                let total = 0;

                this.bets.slice(0, 20).forEach(bet => {
                    if (bet.status !== 'OPEN') {
                        total++;
                        if (bet.status === 'WIN') wins++;
                    }

                    const div = document.createElement('div');
                    div.className = 'history-item';
                    div.innerHTML = `
                        <span class="h-time">${bet.time}</span>
                        <span>${bet.direction}</span>
                        <span>${bet.entry.toFixed(1)}</span>
                        <span class="h-res ${bet.status === 'WIN' ? 'bullish' : (bet.status === 'LOSS' ? 'bearish' : '')}">${bet.status}</span>
                    `;
                    list.appendChild(div);
                });

                const rate = total === 0 ? 0 : Math.round((wins/total)*100);
                document.getElementById('winRate').innerText = `WR: ${rate}%`;
            }
        }

        // Initialize App
        const app = new OracleApp();

    </script>
</body>
</html>